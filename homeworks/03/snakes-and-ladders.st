Object subclass: #BoardSquare	instanceVariableNames: 'position player board'	classVariableNames: ''	poolDictionaries: ''	category: 'SnakesAndLadders'!!BoardSquare commentStamp: '' prior: 0!Responsibilities:- Remember position in the board- Keep track of any players on this square- Send on any players passing through- Displays itself with its position and any player who might be on it, e.g., [7 Jack]!!BoardSquare methodsFor: 'testing'!isLastSquare	^ position = board lastPosition! !!BoardSquare methodsFor: 'testing'!isFirstSquare	^ position = 1! !!BoardSquare methodsFor: 'testing'!isOccupied	^ player notNil! !!BoardSquare methodsFor: 'testing'!position	^ position! !!BoardSquare methodsFor: 'printing'!printOn: aStream	aStream		nextPutAll: '[';		nextPutAll: position printString;		nextPutAll: self contents;		nextPutAll: ']'! !!BoardSquare methodsFor: 'printing'!contents	^ self isOccupied		ifTrue: [ ' ', player asString ]		ifFalse: [ '' ]! !!BoardSquare methodsFor: 'initialize-release'!setPosition: aNumber board: aBoard 	position := aNumber.	board := aBoard! !!BoardSquare methodsFor: 'initialize-release'!invariant	^ board isNotNil		and: [ position isNotNil 		and: [ position between: 0 and: board lastPosition ] ]! !!BoardSquare methodsFor: 'playing'!previousSquare	self assert: self isFirstSquare not.	^ board at: position - 1! !!BoardSquare methodsFor: 'playing'!destination	^ self! !!BoardSquare methodsFor: 'playing'!remove: aPlayer	self assert: player = aPlayer.	player := nil! !!BoardSquare methodsFor: 'playing' stamp: 'Anonymous 11/28/2018 22:00'!acceptVisitor: aVisitor	aVisitor visitBoardSquare: self! !!BoardSquare methodsFor: 'playing'!backwardBy: squares 	^ squares = 0 		ifTrue: [self destination]		ifFalse: 			[self isFirstSquare 				ifTrue: [self nextSquare forwardBy: squares - 1]				ifFalse: [self previousSquare backwardBy: squares - 1]]! !!BoardSquare methodsFor: 'playing'!landHere: aPlayer	^ self isOccupied		ifTrue: [ board firstSquare landHere: aPlayer ]		ifFalse: [ player := aPlayer. self ]! !!BoardSquare methodsFor: 'playing'!forwardBy: squares	self assert: self invariant.	^ squares = 0 		ifTrue: [self destination]		ifFalse: 			[self isLastSquare 				ifFalse: [self nextSquare forwardBy: squares - 1]				ifTrue: [self previousSquare backwardBy: squares - 1]]! !!BoardSquare methodsFor: 'playing'!nextSquare	self assert: self isLastSquare not.	^ board at: position + 1! !Object subclass: #Die	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SnakesAndLadders'!!Die commentStamp: '' prior: 0!Responsibilities:- Yields a random number from 1 to 6 ;-)!!Die methodsFor: 'playing'!roll	^ (1 to: 6) atRandom! !BoardSquare subclass: #FirstSquare	instanceVariableNames: 'players'	classVariableNames: ''	poolDictionaries: ''	category: 'SnakesAndLadders'!!FirstSquare commentStamp: '' prior: 0!Responsibilities:- Allows multiple players to be added or removed [normal squares can only hold a single player]!!FirstSquare methodsFor: 'printing'!contents	^ players inject: '' into:			[ :list :each | list , ' ', each asString ]! !!FirstSquare methodsFor: 'playing'!remove: aPlayer	self assert: (players includes: aPlayer).	players remove: aPlayer.! !!FirstSquare methodsFor: 'playing'!landHere: aPlayer	players add: aPlayer.! !!FirstSquare methodsFor: 'testing'!isOccupied	^ players isNotEmpty! !!FirstSquare methodsFor: 'initialization'!initialize	players := OrderedCollection new.! !!FirstSquare methodsFor: 'initialization' stamp: 'Anonymous 11/28/2018 22:01'!acceptVisitor: aVisitor	aVisitor visitFirstSquare: self! !Object subclass: #GamePlayer	instanceVariableNames: 'name square'	classVariableNames: ''	poolDictionaries: ''	category: 'SnakesAndLadders'!!GamePlayer commentStamp: '' prior: 0!Responsibilities:- Keep track of the square you are on- Roll the die- Attempt to move the resulting number of squares!!GamePlayer methodsFor: 'private'!leaveCurrentSquare	square notNil ifTrue: [ square remove: self ].! !!GamePlayer methodsFor: 'testing'!name	^ name! !!GamePlayer methodsFor: 'testing'!position	^ square position! !!GamePlayer methodsFor: 'printing'!printOn: aStream	aStream nextPutAll: name! !!GamePlayer methodsFor: 'playing'!moveTo: aSquare	self leaveCurrentSquare.	square := aSquare landHere: self.! !!GamePlayer methodsFor: 'playing'!moveWith: aDie	| roll destination |	self assert: self invariant.	roll := aDie roll.	destination := square forwardBy: roll.	self moveTo: destination.	^ name, ' rolls ', roll asString, ' and lands at ', square asString! !!GamePlayer methodsFor: 'initialize-release'!setName: aName	name := aName.! !!GamePlayer methodsFor: 'initialize-release'!invariant	^ square notNil		and: [ name notNil ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GamePlayer class	instanceVariableNames: ''!!GamePlayer class methodsFor: 'instance creation'!named: aName	^ self new setName: aName! !BoardSquare subclass: #LadderSquare	instanceVariableNames: 'forward'	classVariableNames: ''	poolDictionaries: ''	category: 'SnakesAndLadders'!!LadderSquare commentStamp: '' prior: 0!Responsibilities:- If a player lands here, send him or her up the ladder (forward # squares)- Displays itself as a square with a positive offset, e.g., [6]3+>!!LadderSquare methodsFor: 'initialize-release'!setForward: aNumber	forward := aNumber.! !!LadderSquare methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream		nextPutAll: forward asString;		nextPutAll: '+>'! !!LadderSquare methodsFor: 'printing' stamp: 'Anonymous 11/28/2018 22:01'!acceptVisitor: aVisitor	aVisitor visitLadderSquare: self! !!LadderSquare methodsFor: 'printing' stamp: 'Anonymous 11/28/2018 22:01'!forward	^ forward ! !!LadderSquare methodsFor: 'playing'!destination	^ self forwardBy: forward! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!LadderSquare class	instanceVariableNames: ''!!LadderSquare class methodsFor: 'instance creation'!forward: number	^ self new setForward: number! !Die subclass: #LoadedDie	instanceVariableNames: 'roll'	classVariableNames: ''	poolDictionaries: ''	category: 'SnakesAndLadders'!!LoadedDie commentStamp: '' prior: 0!For testing purposes. When rolled, a loaded die returns a fixed value.!!LoadedDie methodsFor: 'playing'!roll: aNumber	self assert: ((1 to: 6) includes: aNumber).	roll := aNumber! !!LoadedDie methodsFor: 'playing'!roll	self assert: roll notNil.	^ roll! !TestCase subclass: #MetaclassHierarchyTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SnakesAndLadders'!!MetaclassHierarchyTest commentStamp: '' prior: 0!Demonstrate the relationship between classes and metaclasses!!MetaclassHierarchyTest methodsFor: 'running'!testHierarchy	"The class hierarchy"	self assert: SnakeSquare superclass equals: BoardSquare.	self assert: BoardSquare superclass equals: Object.	self assert: Object superclass superclass isNil.	"The parallel metaclass hierarchy"	self assert: SnakeSquare class name equals: 'SnakeSquare class'.	self assert: SnakeSquare class superclass equals: BoardSquare class.	self assert: BoardSquare class superclass equals: Object class.	self assert: Object class superclass superclass equals: Class.	self assert: Class superclass equals: ClassDescription.	self assert: ClassDescription superclass equals: Behavior.	self assert: Behavior superclass equals: Object.	"The Metaclass hierarchy"	self assert: SnakeSquare class class equals: Metaclass.	self assert: BoardSquare class class equals: Metaclass.	self assert: Object class class equals: Metaclass.	self assert: Class class class equals: Metaclass.	self assert: ClassDescription class class equals: Metaclass.	self assert: Behavior class class equals: Metaclass.	self assert: Metaclass superclass equals: ClassDescription.	"The fixpoint"	self assert: Metaclass class class equals: Metaclass! !Object subclass: #SLVisitor	instanceVariableNames: 'drawer game'	classVariableNames: ''	poolDictionaries: ''	category: 'SnakesAndLadders'!!SLVisitor commentStamp: '<historical>' prior: 0!Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:For the Class part:  State a one line summary. For example, "I represent a paragraph of text".For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.For the Collaborators Part: State my main collaborators and one line about how I interact with them. Public API and Key Messages- message one   - message two - (for bonus points) how to create instances.   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Instance Variables	drawer:		<Object>	game:		<Object>    Implementation Points!!SLVisitor methodsFor: 'accessing' stamp: 'Anonymous 11/28/2018 22:09'!visitFirstSquare: aSquare	^ self subclassResponsibility! !!SLVisitor methodsFor: 'accessing' stamp: 'Anonymous 11/28/2018 22:09'!visitGame: aGame	drawer clean.	aGame squares do: [ :each | each acceptVisitor: self ]! !!SLVisitor methodsFor: 'accessing' stamp: 'Anonymous 11/28/2018 22:09'!visitBoardSquare: aSquare	^ self subclassResponsibility ! !!SLVisitor methodsFor: 'accessing' stamp: 'Anonymous 11/28/2018 22:09'!visitSnakeSquare: aSquare	^ self subclassResponsibility! !!SLVisitor methodsFor: 'accessing' stamp: 'Anonymous 11/28/2018 22:08'!update	game acceptVisitor: self! !!SLVisitor methodsFor: 'accessing' stamp: 'Anonymous 11/28/2018 22:07'!game	^ game! !!SLVisitor methodsFor: 'accessing' stamp: 'Anonymous 11/28/2018 22:09'!visitLadderSquare: aSquare	^ self subclassResponsibility! !!SLVisitor methodsFor: 'accessing' stamp: 'Anonymous 11/28/2018 22:07'!drawer	^ drawer! !!SLVisitor methodsFor: 'accessing' stamp: 'Anonymous 11/28/2018 22:07'!game: aGame drawer: aDrawer	game := aGame.	drawer := aDrawer.	game addObserver: self.	self update.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SLVisitor class	instanceVariableNames: ''!!SLVisitor class methodsFor: 'as yet unclassified' stamp: 'Anonymous 11/28/2018 22:08'!forGame: aGame drawer: aDrawer	| instance |	instance := self new.	instance game: aGame drawer: aDrawer. 	^ instance! !SLVisitor subclass: #SLHtmlVisitor	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SnakesAndLadders'!!SLHtmlVisitor commentStamp: '<historical>' prior: 0!Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:For the Class part:  State a one line summary. For example, "I represent a paragraph of text".For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.For the Collaborators Part: State my main collaborators and one line about how I interact with them. Public API and Key Messages- message one   - message two - (for bonus points) how to create instances.   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Implementation Points!!SLHtmlVisitor methodsFor: 'visiting' stamp: 'Anonymous 11/28/2018 22:30'!visitFirstSquare: aSquare	drawer addText: '<div class="first">' , aSquare position asString , aSquare contents , '</div>'! !!SLHtmlVisitor methodsFor: 'visiting' stamp: 'Anonymous 11/28/2018 22:42'!visitSnakeSquare: aSquare	drawer addText: '<div class="snake">' , aSquare position asString , '<span>to ' , aSquare destination position asString , '</span></div>'! !!SLHtmlVisitor methodsFor: 'visiting' stamp: 'Anonymous 11/28/2018 22:28'!visitBoardSquare: aSquare	drawer addText: '<div class="board">' , aSquare position asString , aSquare contents , '</div>'! !!SLHtmlVisitor methodsFor: 'visiting' stamp: 'Anonymous 11/28/2018 22:42'!visitLadderSquare: aSquare	drawer addText: '<div class="ladder">' , aSquare position asString , '<span>to ' , aSquare destination position asString , '</span></div>'! !SLVisitor subclass: #SLRoassalVisitor	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SnakesAndLadders'!!SLRoassalVisitor commentStamp: '<historical>' prior: 0!Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:For the Class part:  State a one line summary. For example, "I represent a paragraph of text".For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.For the Collaborators Part: State my main collaborators and one line about how I interact with them. Public API and Key Messages- message one   - message two - (for bonus points) how to create instances.   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Implementation Points!!SLRoassalVisitor methodsFor: 'visiting' stamp: 'Anonymous 11/28/2018 22:46'!visitFirstSquare: aSquare	drawer addTile: (SLBoardTile new square: aSquare)! !!SLRoassalVisitor methodsFor: 'visiting' stamp: 'Anonymous 11/28/2018 22:47'!visitSnakeSquare: aSquare	drawer addTile: (SLSnakeTile new square: aSquare)! !!SLRoassalVisitor methodsFor: 'visiting' stamp: 'Anonymous 11/28/2018 22:46'!visitBoardSquare: aSquare	drawer addTile: (SLBoardTile new square: aSquare).! !!SLRoassalVisitor methodsFor: 'visiting' stamp: 'Anonymous 11/28/2018 22:47'!visitLadderSquare: aSquare	drawer addTile: (SLLadderTile new square: aSquare)! !SLVisitor subclass: #SLTextVisitor	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SnakesAndLadders'!!SLTextVisitor commentStamp: '<historical>' prior: 0!Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:For the Class part:  State a one line summary. For example, "I represent a paragraph of text".For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.For the Collaborators Part: State my main collaborators and one line about how I interact with them. Public API and Key Messages- message one   - message two - (for bonus points) how to create instances.   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Implementation Points!!SLTextVisitor methodsFor: 'visiting' stamp: 'Anonymous 11/28/2018 22:11'!visitFirstSquare: aSquare	drawer addText: aSquare asString! !!SLTextVisitor methodsFor: 'visiting' stamp: 'Anonymous 11/28/2018 22:11'!visitLadderSquare: aSquare	drawer addText: aSquare asString! !!SLTextVisitor methodsFor: 'visiting' stamp: 'Anonymous 11/28/2018 22:11'!visitBoardSquare: aSquare	drawer addText: aSquare asString! !!SLTextVisitor methodsFor: 'visiting' stamp: 'Anonymous 11/28/2018 22:11'!visitSnakeSquare: aSquare	drawer addText: aSquare asString! !BoardSquare subclass: #SnakeSquare	instanceVariableNames: 'back'	classVariableNames: ''	poolDictionaries: ''	category: 'SnakesAndLadders'!!SnakeSquare commentStamp: '' prior: 0!Responsibilities:- If a player lands here, send him or her backwards (back # squares)- Displays itself as a square with a negative offset, e.g., <-3[5]!!SnakeSquare methodsFor: 'playing'!destination	^ self backwardBy: back! !!SnakeSquare methodsFor: 'printing'!printOn: aStream	aStream		nextPutAll: '<-';		nextPutAll: back asString.	super printOn: aStream! !!SnakeSquare methodsFor: 'printing' stamp: 'Anonymous 11/28/2018 22:01'!acceptVisitor: aVisitor	aVisitor visitSnakeSquare: self! !!SnakeSquare methodsFor: 'printing' stamp: 'Anonymous 11/28/2018 22:01'!back	^ back! !!SnakeSquare methodsFor: 'initialize-release'!setBack: aNumber	back := aNumber! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SnakeSquare class	instanceVariableNames: ''!!SnakeSquare class methodsFor: 'instance creation'!back: number	^ self new setBack: number! !Object subclass: #SnakesAndLadders	instanceVariableNames: 'players squares turn die over observers'	classVariableNames: ''	poolDictionaries: ''	category: 'SnakesAndLadders'!!SnakesAndLadders commentStamp: '' prior: 0!SnakesAndLadders examplePlayA simple board game in which players roll a die to move from the starting square to the end. A square may contain a snake (moves you back) or a ladder (moves you up). If youland on a square already occupied, you go back to the start. If you move past the end, you reverse direction the remaining number of moves.See http://en.wikipedia.org/wiki/Snakes_and_ladders for the rules of the gameSnakesAndLadders has the following responsibilities:- enable scripting of an initial configuration of squares and players- keep track of the rules of the game- keep track whose turn it is to play- initiate a move- play a game to the end- report on moves and intermediate game states- stop when the game is overTypical usage (see the example):- Instantiate a new SnakesAndLadders- Add squares, snakes and ladders to build the game board - Join players- Play single moves or playToEnd!!SnakesAndLadders methodsFor: 'playing' stamp: 'Anonymous 11/28/2018 22:17'!acceptVisitor: aVisitor	aVisitor visitGame: self! !!SnakesAndLadders methodsFor: 'playing'!playOneMove	| result |	self assert: self invariant.	^ self isOver		ifTrue: [ 'The game is over!!' ]		ifFalse: [ result := (self currentPlayer moveWith: die) , self checkResult.			self upDateTurn.			result ]! !!SnakesAndLadders methodsFor: 'playing'!playToEnd	"SnakesAndLadders createExample playToEnd"	(Transcript dependents select: #isSystemWindow) do: #close.	Transcript open.	Transcript		show: self asString;		cr;		cr.	[ self isNotOver ]		whileTrue: [ Transcript				show: self playOneMove asString;				cr.			Transcript				show: self asString;				cr;				cr ]! !!SnakesAndLadders methodsFor: 'playing'!checkResult	^ self currentPlayer position = self lastPosition		ifTrue: [			over := true.			' -- ', self currentPlayer asString, ' wins!!'			]		ifFalse: [ '' ]! !!SnakesAndLadders methodsFor: 'playing' stamp: 'Anonymous 11/28/2018 22:04'!upDateTurn	turn := 1 + (turn \\ players size).	observers do: [ :each | each update ]! !!SnakesAndLadders methodsFor: 'accessors'!setDie: aDie	"For testing only. Can play the game with a loaded die."	die := aDie! !!SnakesAndLadders methodsFor: 'accessors'!players	"needed for testing"	^ players! !!SnakesAndLadders methodsFor: 'initialization' stamp: 'Anonymous 11/28/2018 22:03'!initialize	super initialize.	die := Die new.	squares := OrderedCollection new.	players := OrderedCollection new.	observers := OrderedCollection new.	turn := 1.	over := false! !!SnakesAndLadders methodsFor: 'initialization' stamp: 'Anonymous 11/28/2018 22:03'!squares	^ squares! !!SnakesAndLadders methodsFor: 'initialization' stamp: 'Anonymous 11/28/2018 22:03'!addObserver: anObserver	observers add: anObserver ! !!SnakesAndLadders methodsFor: 'accessing'!at: position	^ squares at: position! !!SnakesAndLadders methodsFor: 'initialize-release'!reset	die := Die new.	turn := 1.	over := false.	players do: [ :each | each moveTo: self firstSquare ].	self assert: self invariant! !!SnakesAndLadders methodsFor: 'initialize-release'!join: aPlayer	players add: aPlayer.	aPlayer moveTo: self firstSquare! !!SnakesAndLadders methodsFor: 'initialize-release'!invariant	"Should also check that snakes and ladders lead to ordinary squares, and do not bounce	past the beginning or end of the board."	^ squares size > 1 		and: [ players size > 1 		and: [ turn between: 1 and: players size ] ]! !!SnakesAndLadders methodsFor: 'initialize-release'!add: aSquare 	squares add: aSquare.	aSquare setPosition: squares size board: self! !!SnakesAndLadders methodsFor: 'printing'!printOn: aStream	squares do: [ :each | each printOn: aStream ]! !!SnakesAndLadders methodsFor: 'testing'!isNotOver	^ self isOver not! !!SnakesAndLadders methodsFor: 'testing'!firstSquare	^ squares first! !!SnakesAndLadders methodsFor: 'testing'!lastPosition	^ squares size! !!SnakesAndLadders methodsFor: 'testing'!isOver	^ over! !!SnakesAndLadders methodsFor: 'testing'!turn	^ turn! !!SnakesAndLadders methodsFor: 'testing'!currentPlayer	^ players at: turn! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SnakesAndLadders class	instanceVariableNames: ''!!SnakesAndLadders class methodsFor: 'documentation'!createExample	"self createExample playToEnd"	^ self new		add: FirstSquare new;		add: (LadderSquare forward: 4);		add: BoardSquare new;		add: BoardSquare new;		add: BoardSquare new;		add: BoardSquare new;		add: (LadderSquare forward: 2);		add: BoardSquare new;		add: BoardSquare new;		add: BoardSquare new;		add: (SnakeSquare back: 6);		add: BoardSquare new;		join: (GamePlayer named: 'Jack');		join: (GamePlayer named: 'Jill');		yourself! !!SnakesAndLadders class methodsFor: 'documentation'!example2Play	"self example2play"	^ self createExample2 playToEnd! !!SnakesAndLadders class methodsFor: 'documentation'!createExample2	"self createExample2 playToEnd"	^ self new		add: FirstSquare new;		add: BoardSquare new;		add: (LadderSquare forward: 4);		add: BoardSquare new;		add: BoardSquare new;		add: (SnakeSquare back: 2);		add: BoardSquare new;		add: (LadderSquare forward: 3);		add: BoardSquare new;		add: BoardSquare new;		add: (SnakeSquare back: 4);		add: BoardSquare new;		add: BoardSquare new;		join: (GamePlayer named: 'Jack');		join: (GamePlayer named: 'Jill');		yourself! !!SnakesAndLadders class methodsFor: 'documentation'!examplePlay	"self examplePlay"	^ self createExample playToEnd! !TestCase subclass: #SnakesAndLaddersTest	instanceVariableNames: 'eg loadedDie jack jill'	classVariableNames: ''	poolDictionaries: ''	category: 'SnakesAndLadders'!!SnakesAndLaddersTest commentStamp: '' prior: 0!Play a rigged game and check the results.!!SnakesAndLaddersTest methodsFor: 'running'!setUp	eg := self example.	loadedDie := LoadedDie new.	eg setDie: loadedDie.	jack := eg players first.	jill := eg players last! !!SnakesAndLaddersTest methodsFor: 'running'!example	^ SnakesAndLadders createExample! !!SnakesAndLaddersTest methodsFor: 'running'!testExample	self assert: eg currentPlayer equals: jack.	loadedDie roll: 1.	eg playOneMove.	self assert: jack position equals: 6.	self assert: eg currentPlayer equals: jill.	loadedDie roll: 5.	eg playOneMove.	self assert: jill position equals: 1.	self assert: eg currentPlayer equals: jack.	loadedDie roll: 5.	eg playOneMove.	self assert: jack position equals: 5.	self assert: eg currentPlayer equals: jill.	loadedDie roll: 4.	eg playOneMove.	self assert: jill position equals: 1.	self assert: eg currentPlayer equals: jack.	loadedDie roll: 6.	eg playOneMove.	self assert: jack position equals: 5.	self assert: eg currentPlayer equals: jill.	loadedDie roll: 6.	eg playOneMove.	self assert: jill position equals: 9.	self assert: eg currentPlayer equals: jack.	loadedDie roll: 5.	eg playOneMove.	self assert: jack position equals: 10.	self assert: eg currentPlayer equals: jill.	loadedDie roll: 5.	eg playOneMove.	self assert: jill position equals: 1.	self assert: eg currentPlayer equals: jack.	loadedDie roll: 2.	eg playOneMove.	self assert: jack position equals: 12.	self assert: eg isOver! !!SnakesAndLaddersTest methodsFor: 'running'!testStartPosition	self assert: eg lastPosition equals: 12.	self assert: eg isNotOver.	self assert: eg currentPlayer equals: jack.	self assert: eg firstSquare isFirstSquare.	self assert: eg firstSquare isLastSquare not.	self assert: eg firstSquare position equals: 1.	self assert: eg firstSquare isOccupied.	self assert: (eg at: eg lastPosition) isFirstSquare not.	self assert: (eg at: eg lastPosition) isLastSquare.	self assert: (eg at: eg lastPosition) position equals: 12.	self assert: (eg at: eg lastPosition) isOccupied not.	self assert: jack name equals: 'Jack'.	self assert: jill name equals: 'Jill'.	self assert: jack position equals: 1.	self assert: jill position equals: 1! !SnakesAndLaddersTest subclass: #SnakesAndLaddersTest2	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SnakesAndLadders'!!SnakesAndLaddersTest2 commentStamp: '' prior: 0!Some tests for a second example.!!SnakesAndLaddersTest2 methodsFor: 'running'!testExample	self assert: jack name equals: 'Jack'.	self assert: jill name equals: 'Jill'.	self assert: jack position equals: 1.	self assert: jill position equals: 1.	self assert: eg currentPlayer equals: jack.	loadedDie roll: 1.	eg playOneMove.	self assert: jack position equals: 2.	self assert: eg currentPlayer equals: jill.	loadedDie roll: 2.	eg playOneMove.	self assert: jill position equals: 7.	self assert: eg currentPlayer equals: jack.	loadedDie roll: 3.	eg playOneMove.	self assert: jack position equals: 5.	self assert: eg currentPlayer equals: jill.	loadedDie roll: 1.	eg playOneMove.	self assert: jill position equals: 7.	self assert: eg currentPlayer equals: jack.	loadedDie roll: 2.	eg playOneMove.	self assert: jack position equals: 1.	self assert: eg currentPlayer equals: jill.	loadedDie roll: 5.	eg playOneMove.	self assert: jill position equals: 12.	self assert: eg currentPlayer equals: jack.	loadedDie roll: 6.	eg playOneMove.	self assert: jack position equals: 7.	self assert: eg currentPlayer equals: jill.	loadedDie roll: 1.	eg playOneMove.	self assert: jill position equals: 13.	self assert: eg isOver! !!SnakesAndLaddersTest2 methodsFor: 'running'!example	^ SnakesAndLadders createExample2! !